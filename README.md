#  Тестовый проект: Pokemon application

##  Системные требования

iPhone, iPad c минимальной версией iOS 15.0
(по заданию не была указана, выбрана согласно гайдлайнам Apple, советующим поддерживать последние три версии ОС)

##  Запуск проекта

собирается и запускается стандартными средствами Xcode

##  Немного о задании в общем

Как я понял тут было задание больше на умение построения хорошей ахитектуры проекта.
К сожалению, я до этого момента не работал не с Clean Architecture, не с VIPER.
Я поглубже ознакомился с теоретичскими основами по каждой, и учитывая мой небольшой опыт в разработке на UIKit решил, что лучше чтобы успешнее справиться с заданием выполнить его с использованием SwiftUI, на котором у меня больше опыта.
Поскольку архитектура VIPER не слишком подходит для использования с SwiftUI, и ее реализация требует больших костылей, то мною была выбрана Clean Architecture для реализации этого тестового задания, поскольку она более гибкая в плане требований. В своей работе я во многом руководсвовался [данной статьёй](https://nalexn.github.io/clean-architecture-swiftui/)

Реализованная архитектура показана на следующем рисунке. единственно на ней не изображен уровень содержащий сущности/entities (уровень домена) , однако в данном контексте это не столь важно, поскольку он представлен лишь довольно простыми структурами данных, которые просто используются на почти всех уровнях приложения. 

![image](https://github.com/vasilevsky007/InnowiseTest/assets/72131827/e38b1350-dbb5-44bb-955e-3d8c9e35cbc5) 

Уровень приложения (Application) поделён на Interactors (структуры для взаимодействия с опеределенной моделью, для каждой модели - свой интерактор. Например в данной модели есть интеракторы которые отвечают за работу с сущностями покемонов и за загрузку и кэширование изображений) и AppState (единственный источник истины для представлений всего приложения).

На "внешнем" уровене зависимостей находятся слои интерфейса (View) и доступа к данным (Repositories). Для каждой модели свой репозиторий, также на каждый тип хранилища (в данном проекте используется веб (внешний API) и внутренняя база данных (Core Data))
![image](https://github.com/vasilevsky007/InnowiseTest/assets/72131827/4279f4e1-a828-42e3-adb5-0fb1142f697d)

##  Использованные технологии

### SwiftUI 

Published, Binding, Environment, ObservableObject - для организации data flow в рамках всего приложения

NavigationView, NavigationLink  - для навицации в рамках всего приложения (в рамках того примера на который я ссылался выше была реализована программная навигация (на самом деле просто в зависимости от состояния на общем View показывался один из экранов приложения, а все другие скрывались), но это более UIKit подход, и в рамках SwiftUI я не вижу практического смысла в таком решении, так как если в UIKit нам например неудобно использовать segue посколку по сути сначала вызываемый контроллер инициализируются, и уже потом вручную в него передаются данные(таким образом может достигаться неправильное состояние объекта), а программном вызове мы можем вызвать кастомный конструктор и сразу кооректно сконфигурировать вызываемое представение.
Возможно это может быть полезно только для автоматизированного тестирования представлений, однако по своей сути (в идеальном сценарии) представления в SwiftUI не имеют состояния, которое необходимо тестировать, а только отображают на экране текущее состояние модели, так что достаточно просто превью/симулятора для проверки правильности отображения согласно требованиям самомго интерфейса на различных устройствах)

.alert - для презенции сообщений об ошибках

### Core Data

для хранения на диске резервной копии для работы в режиме оффлайн

### Combine

CurrentValueSubject, Publisher, Cancellable - для поддержания актуальности информации в AppState о размере занимаемой CoreData памяти

### URLSession, Codable, JSONDecoder

для работы с Web API

